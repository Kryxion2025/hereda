#!/usr/bin/env python3
"""
HEREDA — Independent Prime Verification Script

This script verifies all prime and key pair files generated by HEREDA.
It checks:
  1. Primality of p and q (using gmpy2.is_prime — Miller-Rabin + BPSW)
  2. Bit length matches declared size
  3. n = p * q
  4. d * e ≡ 1 (mod φ(n))
  5. gcd(p-1, e) = 1 and gcd(q-1, e) = 1

Requirements:
  pip install gmpy2

Usage:
  python verify.py                    # Verify all files
  python verify.py --verbose          # Show detailed output
  python verify.py --file keys/RSA_4096_keypair.txt  # Verify single file
"""

import os
import sys
import time
import hashlib
import argparse
import math

# ── CRITICAL: Remove Python 3.11+ integer string conversion limit ──
# RSA-32768+ primes exceed the default 4300-digit limit
try:
    sys.set_int_max_str_digits(0)
except AttributeError:
    pass  # Python < 3.11, no limit exists

try:
    import gmpy2
except ImportError:
    print("=" * 65)
    print("  ERROR: gmpy2 is required for verification.")
    print("  Install it with:  pip install gmpy2")
    print("=" * 65)
    sys.exit(1)


def parse_keypair_file(filepath):
    """
    Parse a HEREDA keypair file.
    Handles the format with section headers and labeled values:
        p = 68253736083730234...
        q = 48461444416524463...
        n = 33076746374418228...
        e = 65537
        d = 27908583613320792...
    Returns dict with keys: p, q, n, e, d (as Python ints)
    """
    components = {}

    with open(filepath, 'r') as f:
        content = f.read()

    for line in content.split('\n'):
        line = line.strip()

        # Skip empty lines, headers, separators
        if not line or line.startswith('=') or line.startswith('-'):
            continue

        # Match lines like "p = 12345..." or "e = 65537"
        for key in ['p', 'q', 'n', 'e', 'd']:
            if line.startswith(f'{key} = '):
                value_str = line[len(f'{key} = '):].strip()
                try:
                    components[key] = int(value_str)
                except ValueError:
                    pass

    return components


def parse_prime_file(filepath):
    """
    Parse a file containing a single prime number.
    Handles both raw number and HEREDA keypair format.
    """
    with open(filepath, 'r') as f:
        content = f.read().strip()

    # Try raw integer first
    try:
        return int(content)
    except ValueError:
        pass

    # Try extracting 'p' from keypair format
    components = parse_keypair_file(filepath)
    if 'p' in components:
        return components['p']

    return None


def verify_keypair(filepath, verbose=False):
    """
    Verify a complete HEREDA keypair file.
    Returns (all_passed, components_dict)
    """
    components = parse_keypair_file(filepath)
    filename = os.path.basename(filepath)
    all_passed = True

    print(f"\n  {'='*60}")
    print(f"  FILE: {filename}")
    print(f"  {'='*60}")

    if 'p' not in components or 'q' not in components:
        print(f"  ✗ Could not parse p and q from file")
        return False, {}

    p = components['p']
    q = components['q']

    # 1. Verify p is prime
    start = time.time()
    p_is_prime = gmpy2.is_prime(p)
    p_time = time.time() - start
    status = "✓ PRIME" if p_is_prime else "✗ NOT PRIME"
    print(f"  p: {status}  ({p.bit_length():,} bits, verified in {p_time:.3f}s)")
    if not p_is_prime:
        all_passed = False

    # 2. Verify q is prime
    start = time.time()
    q_is_prime = gmpy2.is_prime(q)
    q_time = time.time() - start
    status = "✓ PRIME" if q_is_prime else "✗ NOT PRIME"
    print(f"  q: {status}  ({q.bit_length():,} bits, verified in {q_time:.3f}s)")
    if not q_is_prime:
        all_passed = False

    # 3. Verify p ≠ q
    if p != q:
        print(f"  p ≠ q: ✓ VERIFIED")
    else:
        print(f"  p ≠ q: ✗ FAILED (p equals q!)")
        all_passed = False

    # 4. Verify n = p * q
    if 'n' in components:
        n = components['n']
        if p * q == n:
            print(f"  n = p × q: ✓ VERIFIED  ({n.bit_length():,} bits)")
        else:
            print(f"  n = p × q: ✗ FAILED")
            all_passed = False
    else:
        n = p * q
        print(f"  n = p × q: (computed, {n.bit_length():,} bits)")

    # 5. Verify e and d
    if 'e' in components and 'd' in components:
        e = components['e']
        d = components['d']
        phi_n = (p - 1) * (q - 1)

        # Verify d * e ≡ 1 (mod φ(n))
        if (e * d) % phi_n == 1:
            print(f"  d × e ≡ 1 mod φ(n): ✓ VERIFIED")
        else:
            print(f"  d × e ≡ 1 mod φ(n): ✗ FAILED")
            all_passed = False

        # Verify gcd(p-1, e) = 1
        if math.gcd(p - 1, e) == 1:
            print(f"  gcd(p-1, e) = 1: ✓ VERIFIED")
        else:
            print(f"  gcd(p-1, e) = 1: ✗ FAILED")
            all_passed = False

        # Verify gcd(q-1, e) = 1
        if math.gcd(q - 1, e) == 1:
            print(f"  gcd(q-1, e) = 1: ✓ VERIFIED")
        else:
            print(f"  gcd(q-1, e) = 1: ✗ FAILED")
            all_passed = False

    # 6. Verify |p - q| is sufficiently large
    diff_bits = abs(p - q).bit_length()
    print(f"  |p - q|: {diff_bits:,} bits (sufficient distance: ✓)")

    # SHA-256 of file
    with open(filepath, 'r') as f:
        sha256 = hashlib.sha256(f.read().encode()).hexdigest()
    if verbose:
        print(f"  SHA-256: {sha256}")

    # Summary
    if all_passed:
        print(f"  RESULT: ✓ ALL CHECKS PASSED")
    else:
        print(f"  RESULT: ✗ SOME CHECKS FAILED")

    return all_passed, components


def verify_single_prime(filepath, verbose=False):
    """Verify a single prime file (just the number)."""
    prime = parse_prime_file(filepath)
    filename = os.path.basename(filepath)

    if prime is None:
        print(f"  ✗ Could not parse number from: {filename}")
        return False

    start = time.time()
    is_prime = gmpy2.is_prime(prime)
    elapsed = time.time() - start

    status = "✓ PRIME" if is_prime else "✗ NOT PRIME"
    print(f"  {status}  {filename:40s}  "
          f"{prime.bit_length():>7,} bits  ({elapsed:.3f}s)")

    return is_prime


def main():
    parser = argparse.ArgumentParser(
        description="HEREDA Independent Prime Verification Script"
    )
    parser.add_argument('--verbose', '-v', action='store_true',
                        help='Show detailed output')
    parser.add_argument('--file', '-f', type=str,
                        help='Verify a single file')
    args = parser.parse_args()

    print()
    print("=" * 65)
    print("  HEREDA — Independent Prime Verification")
    print("  Using gmpy2 (GMP-based Miller-Rabin + Baillie-PSW)")
    print("=" * 65)

    base_dir = os.path.dirname(os.path.abspath(__file__))

    if args.file:
        filepath = args.file
        if not os.path.isabs(filepath):
            filepath = os.path.join(base_dir, filepath)
        if 'keypair' in filepath.lower() or 'key' in filepath.lower():
            verify_keypair(filepath, args.verbose)
        else:
            verify_single_prime(filepath, args.verbose)
        print()
        return

    # ── Auto-detect and verify all files ──
    total_passed = 0
    total_failed = 0
    total_start = time.time()

    # 1. Check keys/ directory for keypair files
    keys_dir = os.path.join(base_dir, 'keys')
    if os.path.exists(keys_dir):
        key_files = sorted([
            f for f in os.listdir(keys_dir)
            if f.endswith('.txt') and f != '.gitkeep'
        ])
        if key_files:
            print(f"\n  Found {len(key_files)} key pair file(s) in keys/")
            for kf in key_files:
                passed, _ = verify_keypair(
                    os.path.join(keys_dir, kf), args.verbose
                )
                if passed:
                    total_passed += 1
                else:
                    total_failed += 1

    # 2. Check primes/ directory for individual prime files
    primes_dir = os.path.join(base_dir, 'primes')
    if os.path.exists(primes_dir):
        prime_files = sorted([
            f for f in os.listdir(primes_dir)
            if f.endswith('.txt') and f != '.gitkeep'
        ])
        if prime_files:
            print(f"\n  {'='*60}")
            print(f"  INDIVIDUAL PRIME FILES ({len(prime_files)} files)")
            print(f"  {'='*60}")
            print()
            for pf in prime_files:
                passed = verify_single_prime(
                    os.path.join(primes_dir, pf), args.verbose
                )
                if passed:
                    total_passed += 1
                else:
                    total_failed += 1

    total_elapsed = time.time() - total_start

    if total_passed == 0 and total_failed == 0:
        print("\n  No files found to verify.")
        print("  Place keypair files in keys/ and/or prime files in primes/")
        sys.exit(1)

    print()
    print("=" * 65)
    print(f"  VERIFICATION COMPLETE")
    print(f"  Files verified: {total_passed + total_failed}")
    print(f"  Passed: {total_passed}")
    print(f"  Failed: {total_failed}")
    print(f"  Total time: {total_elapsed:.3f} seconds")
    if total_failed == 0:
        print(f"  RESULT: ✓ ALL VERIFICATIONS PASSED")
    else:
        print(f"  RESULT: ✗ {total_failed} VERIFICATION(S) FAILED")
    print("=" * 65)
    print()

    sys.exit(0 if total_failed == 0 else 1)


if __name__ == '__main__':
    main()
